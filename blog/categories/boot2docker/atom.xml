<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Boot2docker | Ian Blenke - DevOps]]></title>
  <link href="http://ianblenke.github.io/blog/categories/boot2docker/atom.xml" rel="self"/>
  <link href="http://ianblenke.github.io/"/>
  <updated>2014-11-05T16:21:06-05:00</updated>
  <id>http://ianblenke.github.io/</id>
  <author>
    <name><![CDATA[Ian Blenke]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Self-standing Ceph/deis-store Docker Containers]]></title>
    <link href="http://ianblenke.github.io/blog/2014/11/05/self-standing-ceph-slash-deis-store-docker-containers/"/>
    <updated>2014-11-05T14:40:59-05:00</updated>
    <id>http://ianblenke.github.io/blog/2014/11/05/self-standing-ceph-slash-deis-store-docker-containers</id>
    <content type="html"><![CDATA[<p>A common challenge for cloud orchestration is simulating or providing an S3 service layer, particularly for development environments.</p>

<p>As Docker is meant for immutable infrastructure, this poses somewhat of a challenge for production deployments. Rather than tackle that subject here, we&rsquo;ll revisit persistence on immutable infrastructure in a production capacity in a future blog post.</p>

<p>The first challenge is identifying an S3 implementation to throw into a container.</p>

<p>There are a few feature sparse/dummy solutions that might suit development needs:</p>

<ul>
<li><a href="http://s3ninja.net/">s3-ninja</a> (github <a href="https://github.com/scireum/s3ninja">scireum/s3ninja</a>)</li>
<li><a href="https://github.com/jubos/fake-s3">fake-s3</a></li>
<li><a href="http://sourceforge.net/projects/s3mockup/">S3Mockup</a>
(and a number of others which I&rsquo;d rather not even consider)</li>
</ul>


<p>There are a few good functional options for actual S3 implementations:</p>

<ul>
<li><a href="http://ceph.com">ceph</a> (github <a href="https://github.com/ceph/ceph">ceph/ceph</a>), specifically the <a href="http://ceph.com/docs/master/radosgw/">radosgw</a></li>
<li><a href="https://github.com/eucalyptus/eucalyptus/wiki/Walrus-S3-API">walrus</a> from Eucalyptus</li>
<li><a href="http://basho.com/riak-cloud-storage/">riak cs</a></li>
<li><a href="http://www.skylable.com/download/#LibreS3">libres3</a>, backended by the opensource <a href="http://www.skylable.com/download/#SX">Skylable Sx</a></li>
<li><a href="https://github.com/nimbusproject/nimbus/tree/master/cumulus">cumulus</a> is an S3 implementation for <a href="http://www.nimbusproject.org/docs/current/faq.html#cumulus">Nimbus</a></li>
<li><a href="http://www.cloudian.com/community-edition.php">cloudian</a> which is a non-opensource commercial product</li>
<li><a href="https://github.com/stackforge/swift3">swift3</a> as an S3 compatibility layer with swift on the backend</li>
<li><a href="https://github.com/cloudfoundry-attic/vblob">vblob</a> a node.js based attic&#8217;ed project at CloudFoundry</li>
<li><a href="https://github.com/mattjamieson/parkplace">parkplace</a> backended by bittorrent</li>
<li><a href="[https://github.com/razerbeans/boardwalk]">boardwalk</a> backended by ruby, sinatra, and mongodb</li>
</ul>


<p>Of the above, one stands out as the underlying persistence engine used by a larger docker backended project: <a href="http://deis.io">Deis</a></p>

<p>Rather than re-invent the wheel, it is possible to use deis-store directly.</p>

<p>As Deis deploys on CoreOS, there is an understandable inherent dependency on <a href="http://github.com/coreos/etcd/">etcd</a> for service discovery.</p>

<p>If you happen to be targeting CoreOS, you can simply point your etcd &ndash;peers option or <code>ETCD_HOST</code> environment variable at <code>$COREOS_PRIVATE_IPV4</code> and skip this next step.</p>

<p>First, make sure your environment includes the <code>DOCKER_HOST</code> and related variables for the boot2docker environment:</p>

<pre><code>eval $(boot2docker shellinit)
</code></pre>

<p>Now, discover the IP of the boot2docker guest VM, as that is what we will bind the etcd to:</p>

<pre><code>IP="$(boot2docker ip 2&gt;/dev/null)"
</code></pre>

<p>Next, we can spawn etcd and publish the ports for the other containers to use:</p>

<pre><code>docker run --name etcd \
           --publish 4001:4001 \
           --publish 7001:7001 \
           --detach \
           coreos/etcd:latest \
           /go/bin/app -listen-client-urls http://0.0.0.0:4001 \
                       -advertise-client-urls http://$IP:4001 \
                       -listen-peer-urls http://0.0.0.0:7001 \
                       -initial-advertise-peer-urls http://$IP:7001 \
                       -data-dir=/tmp/etcd
</code></pre>

<p>Normally, we wouldn&rsquo;t put the etcd persistence in a tmpfs for consistency reasons after a reboot, but for a development container: we love speed!</p>

<p>Now that we have an etcd container running, we can spawn the deis-store daemon container that runs the ceph object-store daemon (OSD) module.</p>

<pre><code>docker run --name deis-store-daemon \
           --volumes-from=deis-store-daemon-data \
           --env HOST=$IP \
           --publish 6800 \
           --net host \
           --detach \
           deis/store-daemon:latest
</code></pre>

<p>It is probably a good idea to mount the /var/lib/deis/store volume for persistence, but this is a developer container, so we&rsquo;ll forego that step.</p>

<p>The ceph-osd will wait in a loop when starting until it can talk to ceph-mon, which is the next component provided by the deis-store monitor container.</p>

<p>In order to prepare the etcd config tree for deis-store monitor, we must first set a key for this new deis-store-daemon component.</p>

<p>While we could do that with a wget/curl PUT to the etcd client port (4001), using etcdctl makes things a bit easier.</p>

<p>It is generally a good idea to match the version of the etcdctl client with the version of etcd you are using.</p>

<p>As the CoreOS team doesn&rsquo;t put out an etcdctl container as of yet, one way to do this is to build/install etcdctl inside a coreos/etcd container:</p>

<pre><code>docker run --rm \
           coreos/etcd \
           /bin/sh -c "cd /go/src/github.com/coreos/etcd/etcdctl; go install ; /go/bin/etcdctl --peers $IP:4001 set /deis/store/hosts/$IP $IP"
</code></pre>

<p>This isn&rsquo;t ideal, of course, as there is a slight delay as etcdctl is built and installed before we use it, but it serves the purpose.</p>

<p>There are also <a href="http://docs.deis.io/en/latest/managing_deis/store_daemon_settings/">deis/store-daemon settings</a> of etcd keys that customize the behavior of ceph-osd a bit.</p>

<p>Now we can start deis-store-monitor, which will use that key to spin up a ceph-mon that monitors this (and any other) ceph-osd instances likewise registered in the etcd configuration tree.</p>

<pre><code>docker run --name deis-store-monitor \
           --env HOST=$IP \
           --publish 6789 \
           --net host \
           --detach \
           deis/store-monitor:latest
</code></pre>

<p>As before, there are volumes that probably should be mounted for /etc/ceph and /var/lib/ceph/mon, but this is a development image, so we&rsquo;ll skip that.</p>

<p>There are also <a href="http://docs.deis.io/en/latest/managing_deis/store_monitor_settings/">deis/store-monitor settings</a> of etcd keys that customize the behavior of ceph-mon a bit.</p>

<p>Now that ceph-mon is running, ceph-osd will continue starting up. We now have a single-node self-standing ceph storage platform, but no S3.</p>

<p>The S3 functionality is provided by the ceph-radosgw component, which is provided by the deis-store-gateway container.</p>

<pre><code>docker run --name deis-store-gateway \
           --hostname deis-store-gateway \
           --env HOST=$IP \
           --env EXTERNAL_PORT=8888 \
           --publish 8888:8888 \
           --detach \
           deis/store-gateway:latest
</code></pre>

<p>There is no persistence in ceph-radosgw that warrant a volume mapping, so we can ignore that entirely regardless of environment.</p>

<p>There are also <a href="http://docs.deis.io/en/latest/managing_deis/store_gateway_settings/">deis/store-gateway settings</a> of etcd keys that customize the behavior of ceph-radosgw a bit.</p>

<p>We now have a functional self-standing S3 gateway, but we don&rsquo;t know the credentials to use it. For that, we can run etcdctl again:</p>

<pre><code>AWS_ACCESS_KEY_ID=$(docker run --rm coreos/etcd /bin/sh -c "cd /go/src/github.com/coreos/etcd/etcdctl; go install ; /go/bin/etcdctl --peers $IP:4001 get /deis/store/gateway/accessKey")
AWS_SECRET_ACCESS_KEY=$(docker run --rm coreos/etcd /bin/sh -c "cd /go/src/github.com/coreos/etcd/etcdctl; go install ; /go/bin/etcdctl --peers $IP:4001 get /deis/store/gateway/secretKey")
AWS_S3_HOST=$(docker run --rm coreos/etcd /bin/sh -c "cd /go/src/github.com/coreos/etcd/etcdctl; go install ; /go/bin/etcdctl --peers $IP:4001 get /deis/store/gateway/host")
AWS_S3_PORT=$(docker run --rm coreos/etcd /bin/sh -c "cd /go/src/github.com/coreos/etcd/etcdctl; go install ; /go/bin/etcdctl --peers $IP:4001 get /deis/store/gateway/port")
</code></pre>

<p>Note that the host here isn&rsquo;t the normal AWS gateway address, so you will need to specify things for your S3 client to access it correctly.</p>

<p>Likewise, you may need to specify an URL scheme of &ldquo;http&rdquo;, as the above does not expose an HTTPS encrypted port.</p>

<p>There are also S3 client changes that (may be necessary)[<a href="https://github.com/deis/deis/issues/2326">https://github.com/deis/deis/issues/2326</a>] depending on the &ldquo;calling format&rdquo; of the client libraries. You may need to <a href="http://stackoverflow.com/questions/24312350/using-paperclip-fog-and-ceph">changes things like paperclip</a> to <a href="https://github.com/thoughtbot/paperclip/issues/1577">work with fog</a>. There are numerous tools that work happily with ceph, like <a href="https://github.com/stiller/s3_to_ceph/blob/master/s3_to_ceph.rb">s3_to_ceph</a> and even gems like <a href="https://github.com/fog/fog-radosgw">fog-radosgw</a> that try and help make this painless for your apps.</p>

<p>I will update this blog post shortly with an example of a containerized s3 client to show how to prove your ceph radosgw is working.</p>

<p>Have fun!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Boot2Docker]]></title>
    <link href="http://ianblenke.github.io/blog/2014/11/04/using-boot2docker/"/>
    <updated>2014-11-04T23:13:25-05:00</updated>
    <id>http://ianblenke.github.io/blog/2014/11/04/using-boot2docker</id>
    <content type="html"><![CDATA[<h2>Boot2Docker command-line</h2>

<p>Preface: the <a href="https://github.com/boot2docker/boot2docker">boot2docker README</a> is a great place to discover the below commands in more detail.</p>

<p>Now that we have Boot2Docker installed, we need to initialize a VM instance</p>

<pre><code>boot2docker init
</code></pre>

<p>This merely defines the default boot2docker VM, it does not start it. To do that, we need to bring it &ldquo;up&rdquo;</p>

<pre><code>boot2docker up
</code></pre>

<p>When run, it looks something like this:</p>

<pre><code>icbcfmbp:~ icblenke$ boot2docker up
Waiting for VM and Docker daemon to start...
..........ooo
Started.
Writing /Users/icblenke/.boot2docker/certs/boot2docker-vm/ca.pem
Writing /Users/icblenke/.boot2docker/certs/boot2docker-vm/cert.pem
Writing /Users/icblenke/.boot2docker/certs/boot2docker-vm/key.pem

To connect the Docker client to the Docker daemon, please set:
    export DOCKER_CERT_PATH=/Users/icblenke/.boot2docker/certs/boot2docker-vm
    export DOCKER_TLS_VERIFY=1
    export DOCKER_HOST=tcp://192.168.59.103:2376

icbcfmbp:~ icblenke$
</code></pre>

<p>This is all fine and dandy, but that shell didn&rsquo;t actually source those variables. To do that we use boot2docker shellinit:</p>

<pre><code>eval $(boot2docker shellinit)
</code></pre>

<p>Now the shell has those variables exported for the running boot2docker VM.</p>

<p>The persistence of the boot2docker VM lasts only until we run a boot2docker destroy</p>

<pre><code>boot2docker destroy
</code></pre>

<p>After doing this, there is no longer a VM defined. We would need to go back to the boot2docker init step above and repeat.</p>

<h2>Docker command-line</h2>

<p>From this point forward, we use the docker command to interact with the boot2docker VM as if we are on a linux docker host.</p>

<p>The docker command is just a compiled go application that makes RESTful calls to the docker daemon inside the linux VM.</p>

<pre><code>bash-3.2$ docker info
Containers: 0
Images: 0
Storage Driver: aufs
 Root Dir: /mnt/sda1/var/lib/docker/aufs
  Dirs: 0
  Execution Driver: native-0.2
  Kernel Version: 3.16.4-tinycore64
  Operating System: Boot2Docker 1.3.1 (TCL 5.4); master : 9a31a68 - Fri Oct 31 03:14:34 UTC 2014
  Debug mode (server): true
  Debug mode (client): false
  Fds: 10
  Goroutines: 11
  EventsListeners: 0
  Init Path: /usr/local/bin/docker
</code></pre>

<p>This holds true for both OS/X and Windows.</p>

<p>The boot2docker facade is just a handy wrapper to prepare the guest linux host VM for the docker daemin and local docker command-line client for your development host OS environment.</p>

<p>And now you have a starting point for exploring <a href="http://docker.io">Docker</a>!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Installing Boot2Docker]]></title>
    <link href="http://ianblenke.github.io/blog/2014/11/04/installing-boot2docker/"/>
    <updated>2014-11-04T22:41:53-05:00</updated>
    <id>http://ianblenke.github.io/blog/2014/11/04/installing-boot2docker</id>
    <content type="html"><![CDATA[<p>Starting with a new team of developers, it helps to document the bootstrapping steps to a development environment.</p>

<p>Rather than try and use a convergence tool like Chef, Puppet, Ansible, or SALT, this time the environment will embrace Docker.</p>

<p>We could use a tool like Vagrant, but we need to support both Windows and Mac development workstations, and Vagrant under Windows can be vexing.</p>

<p>For this, we will begin anew using <a href="http://boot2docker.io">Boot2Docker</a></p>

<p>Before we begin, be sure to install <a href="https://www.virtualbox.org/">VirtualBox</a> from Oracle&rsquo;s <a href="https://www.virtualbox.org/">VirtualBox.org website</a></p>

<p>The easiest way to install VirtualBox is to use <a href="http://caskroom.io/">HomeBrew Cask</a> under <a href="http://brew.sh">HomeBrew</a></p>

<pre><code>brew install caskroom/cask/brew-cask
brew cask install virtualbox
</code></pre>

<p>The easiest way to install boot2docker is to use <a href="http://brew.sh">HomeBrew</a></p>

<pre><code>brew install boot2docker
</code></pre>

<p>Afterward, be sure to upgrade the homebrew bottle to the latest version of boot2docker:</p>

<pre><code>boot2docker upgrade
</code></pre>

<p>Alternatively, a sample commandline install of boot2docker might look like this:</p>

<pre><code>wget https://github.com/boot2docker/osx-installer/releases/download/v1.3.1/Boot2Docker-1.3.1.pkg
sudo installer -pkg ~/Downloads/Boot2Docker-1.3.1.pkg -target /
</code></pre>

<p>I&rsquo;ll leave the commandline install of VirtualBox up to your imagination. With <a href="http://caskroom.io">HomeBrew Cask</a>, there&rsquo;s really not much of a point.</p>

<p>If you&rsquo;re still not comfortable, below is a pictoral screenshot guide to installing boot2docker the point-and-click way.</p>

<h2>Step 0</h2>

<p>Download <a href="https://github.com/boot2docker/osx-installer/releases">boot2docker for OS/X</a> or <a href="https://github.com/boot2docker/windows-installer/releases">boot2docker for Windows</a></p>

<h2>Step 1</h2>

<p>Run the downloaded Boot2Docker.pkg or docker-install.exe to kick off the installer.</p>

<p><img src="/images/screenshots/boot2docker/step1-downloads.png" width="1636" height="1022" title="&lsquo;Downloads&rsquo; &lsquo;Boot2docker.pkg in Downloads folder&rsquo;" ></p>

<h2>Step 2</h2>

<p>Click the Continue button to allow the installer to run a program to detect if boot2docker can be installed.</p></p>

<p><img src="/images/screenshots/boot2docker/step2-run-a-program.png" width="1318" height="968" title="&lsquo;Click Continue button&rsquo; &lsquo;Allow installer to run a program to detect if boot2docker can be installed&rsquo;" ></p>

<h2>Step 3</h2>

<p>Click the Continue button to proceed beyond the initial installation instructions dialog.</p>

<p><img src="/images/screenshots/boot2docker/step3-install-splash.png" width="1316" height="944" title="&lsquo;Click Continue button&rsquo; &lsquo;Instructions to install boot2docker&rsquo;" ></p>

<h2>Step 4</h2>

<p>The installer will now ask for an admin username/password to obtain admin rights to install boot2docker.</p>

<p><img src="/images/screenshots/boot2docker/step4-enter-password.png" width="1390" height="1104" title="&lsquo;Enter your password&rsquo; &lsquo;Installer asks for admin rights to install boot2docker&rsquo;" ></p>

<h2>Step 5</h2>

<p>Before installing, the installer will advise how much space the install will take. Click the Install button to start the actual install.</p>

<p><img src="/images/screenshots/boot2docker/step5-standard-install.png" width="1310" height="968" title="&lsquo;Click Install button&rsquo; &lsquo;Advice on how much space boot2docker will take when installed&rsquo;" ></p>

<h2>Step 6</h2>

<p>When the installation is successfully, click the Close button to exit the installer.</p>

<p><img src="/images/screenshots/boot2docker/step6-install-completed-successfully.png" width="1334" height="984" title="&lsquo;Click Close button&rsquo; &lsquo;Install completed successfully&rsquo;" ></p>

<h2>Step 7</h2>

<p>You now have a shiny icon for boot2docker in /Applications you can click on to start a boot2docker terminal window session.</p>

<p><img src="/images/screenshots/boot2docker/step7-installed-boot2docker-app.png" width="1352" height="1006" title="&lsquo;Run boot2docker app&rsquo; &lsquo;Boot2docker app is in Applications&rsquo;" ></p>

<p>Congrats. You now have boot2docker installed.</p>
]]></content>
  </entry>
  
</feed>
